#[cfg(feature = "print_schema")]
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    /// Print Schema
    #[derive(argh::FromArgs)]
    pub struct Arguments {
        /// database connection string for PostgreSQL
        #[argh(option, short = 'd')]
        db: String,

        /// where to store generated schema file
        #[argh(option, short = 'o')]
        out: Option<std::path::PathBuf>,

        /// specific database schema to use
        #[argh(option, short = 's')]
        schema: Option<String>,
    }

    let args: Arguments = argh::from_env();

    let (client, connection) = tokio_postgres::connect(&args.db, tokio_postgres::NoTls).await?;

    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!("connection error: {}", e);
        }
    });

    let schema = thorn::generate::generate(&client, args.schema.clone()).await?;

    if let Some(out) = args.out {
        use std::io::Write;

        let mut file = std::fs::OpenOptions::new().create(true).truncate(true).write(true).open(out)?;

        match args.schema {
            Some(schema) => write!(file, "//! Autogenerated Schema for \"{schema}\"\n\n")?,
            None => write!(file, "//! Autogenerated Schema")?,
        }

        file.write_all(schema.as_bytes())?;
    } else {
        println!("{schema}");
    }

    Ok(())
}

#[cfg(not(feature = "print_schema"))]
fn main() {
    eprintln!("This binary was compiled without the `print_schema` feature enabled.");
    eprintln!("Please enable the `print_schema` feature in your `Cargo.toml` to use this binary.");
    std::process::exit(1);
}
