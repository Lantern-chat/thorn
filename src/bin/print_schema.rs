#![cfg(feature = "print_schema")]

/// Print Schema
#[derive(argh::FromArgs)]
pub struct Arguments {
    /// database connection string for PostgreSQL
    #[argh(option, short = 'd')]
    db: String,

    /// where to store generated schema file
    #[argh(option, short = 'o')]
    out: Option<std::path::PathBuf>,

    /// specific database schema to use
    #[argh(option, short = 's')]
    schema: Option<String>,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args: Arguments = argh::from_env();

    let (client, connection) = tokio_postgres::connect(&args.db, tokio_postgres::NoTls).await?;

    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!("connection error: {}", e);
        }
    });

    let schema = thorn::generate::generate(&client, args.schema.clone()).await?;

    if let Some(out) = args.out {
        use std::io::Write;

        let mut file = std::fs::OpenOptions::new().create(true).truncate(true).write(true).open(out)?;

        match args.schema {
            Some(schema) => write!(file, "//! Autogenerated Schema for \"{schema}\"\n\n")?,
            None => write!(file, "//! Autogenerated Schema")?,
        }

        file.write_all(schema.as_bytes())?;
    } else {
        println!("{schema}");
    }

    Ok(())
}
